// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

package main

import (
	"encoding/csv"
	"fmt"
	"go/build"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"golang.org/x/arch/x86/x86asm"
)

var known = knownOps()

func main() {
	fmt.Print(`// Generated by mkx86info.go. DO NOT EDIT.

package asm

import "golang.org/x/arch/x86/x86asm"

type x86ArgsKey struct {
	op   x86asm.Op
	narg int
}

type effect uint8

const (
	r  effect = 1<<iota
	w
	rw        = r|w
)

const (
	rm8  x86asm.Op = iota << 16
	rm16
	rm32
	rm64
)

`)

	argEfects(filepath.Join(findPkg("golang.org/x/arch/x86/x86asm"), "../x86.v0.2.csv"))
	implicitEffects("implicit.csv")
}

func findPkg(pkg string) string {
	p, err := build.Import(pkg, ".", build.FindOnly)
	if err != nil {
		log.Fatal(err)
	}
	return p.Dir
}

func readCSV(path string) [][]string {
	f, err := os.Open(path)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	r := csv.NewReader(f)
	r.Comment = '#'
	r.FieldsPerRecord = -1

	recs, err := r.ReadAll()
	if err != nil {
		log.Fatal(err)
	}

	return recs
}

// argEffects reads an x86map CSV file and emits a table of
// argument-based effetcs.
func argEfects(path string) {
	recs := readCSV(path)

	fmt.Println("var x86Args = map[x86ArgsKey][]effect{")

	type rwKey struct {
		string
		int
	}
	rws := make(map[rwKey]string)
	for _, rec := range recs {
		op := strings.Fields(rec[0])[0]
		tags := rec[7]
		rw := rec[8]

		if strings.Contains(tags, "pseudo") {
			continue
		}
		if !known[op] {
			continue
		}

		// Fix some errors in the manual.
		switch op {
		case "SBB":
			rw = "rw,r"
		case "XCHG":
			rw = "rw,rw"

		case "MOVHPD", "MOVHPS", "MOVLPD", "MOVLPS":
			// These are more complicated, so we
			// special-case them in the actual logic.
			continue
		}

		args := strings.Split(rw, ",")
		if rw == "" {
			args = []string{}
		}

		if have, ok := rws[rwKey{op, len(args)}]; ok {
			if rw != have {
				log.Fatalf("multiple r/w patterns for %s/%d", op, len(args))
			}
			continue
		}
		rws[rwKey{op, len(args)}] = rw

		fmt.Printf("\t{x86asm.%s, %d}: {", op, len(args))
		for i, arg := range args {
			if i > 0 {
				fmt.Printf(", ")
			}
			switch arg {
			case "r", "rw", "w":
				fmt.Print(arg)
			default:
				log.Fatalf("unknown effect %q", arg)
			}
		}
		fmt.Printf("},\n")
	}

	fmt.Print("}\n\n")
}

func implicitEffects(path string) {
	recs := readCSV(path)

	fmt.Println("var x86Implicit = map[x86asm.Op]struct {r, w []x86asm.Reg}{")
	for _, rec := range recs {
		for _, op := range expandBrackets(rec[0]) {
			subs := strings.Fields(op)
			if !known[subs[0]] {
				continue
			}

			switch len(subs) {
			default:
				panic("bad op pattern " + op)
			case 1:
				fmt.Printf("\tx86asm.%s: ", subs[0])
			case 2:
				fmt.Printf("\tx86asm.%s | %s: ", subs[0], subs[1])
			}
			r, w := parseEffects(rec[1])
			fmt.Printf("{%s, %s},\n", r, w)
		}
	}
	fmt.Print("}\n\n")
}

func expandBrackets(s string) []string {
	i := strings.IndexByte(s, '[')
	if i < 0 {
		return []string{s}
	}
	pre, s := s[:i], s[i+1:]
	li := strings.IndexByte(s, ']')
	s, post := s[:li], s[li+1:]

	out := []string{}
	if dash := strings.IndexByte(s, '-'); dash >= 0 {
		low, _ := strconv.Atoi(s[:dash])
		hi, _ := strconv.Atoi(s[dash+1:])
		for i := low; i <= hi; i++ {
			out = append(out, fmt.Sprintf("%s%d%s", pre, i, post))
		}
	} else {
		for _, ch := range s {
			out = append(out, pre+string(ch)+post)
		}
	}
	return out
}

func parseEffects(s string) (r, w string) {
	r = "[]x86asm.Reg{"
	w = r
	set := &w
	for _, rs := range strings.Fields(s) {
		if rs == "<-" {
			set = &r
			continue
		}
		for _, r := range expandBrackets(rs) {
			if r == "mem" {
				*set += "x86asm.Reg(0), "
			} else {
				*set += "x86asm." + r + ", "
			}
		}
	}
	r, w = r+"}", w+"}"
	return
}

// knownOps returns the opcode names known to the x86asm package.
func knownOps() map[string]bool {
	// There are various complex rules about which ops x86map
	// includes in x86asm's tables. Rather than try to reproduce
	// those, we just enumerate which Ops are string-able.
	known := make(map[string]bool)
	for i := x86asm.Op(1); ; i++ {
		op := i.String()
		if strings.HasPrefix(op, "Op(") {
			break
		}
		known[op] = true
	}
	return known
}
